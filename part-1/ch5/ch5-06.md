## 5.6  搜索过滤 Filtering a search ##


&emsp;&emsp;过滤是 Lucene 中用于缩小搜索空间的一种机制，它把搜索结果限制在所有可能匹配文档(document)的一个子集中。它们可以用来对已经得到的搜索匹配结果进行进一步的搜索，以实现在搜索结果中继续搜索的特性(search-within-search)，或者约束文档搜索空间。安全过滤器(A security filter)使用户只能看到属于他“自己的”文档的搜索结果，即便这些查询实际上还匹配了其它的文档。我们将在5.6.7节给出一个安全过滤器的例子。

&emsp;&emsp;旧版本 Lucene 以 org.apache.lucene.search.Filter 为基类，提供了一系列的过滤器，用于针对不同需求的过滤，例如 TermRangeFilter，NumericRangeFilter，FieldCacheRangeFilter，FieldCacheTermsFilter，QueryWrapperFilter，SpanQueryFilter，PrefixFilter，CachingWrapperFilter，CachingSpanFilter，FilteredDocIdSet 等等。

&emsp;&emsp;其实，过滤器从概念上讲就是没有评分的查询(Query)，因此，在 Lucene 5.4 版之后，Filter 系列过滤类被标记为 @Deprecated，到 6.0 版被彻底移除，取而代之的是 ConstantScoreQuery 类和 BooleanClause.Occur.FILTER 枚举值。

You can use Query objects directly for filtering by using BooleanClause.Occur.FILTER clauses in a BooleanQuery.

&emsp;&emsp;ConstantScoreQuery 是一个包装类，可以使用任何类型的 Query 创建，只是如其类名所暗示， ConstantScoreQuery 查询返回的所有匹配文档的评分值(score)为恒定的值1。 

&emsp;&emsp;BooleanClause.Occur.FILTER 是 Lucene 5.1 新增的一个布尔查询子句操作符，这个操作符类似于 BooleanClause.Occur.MUST，表示加入到 BooleanQuery 的子句**必须**出现在匹配的文档中。区别是 MUST 操作符表示的子句参与匹配结果的评分计算中，而 FILTER 操作符表示的子句不参与匹配结果的评分，即它仅起到对匹配结果的过滤作用。因此，FILTER 是比 MUST 更轻量的操作符。

&emsp;&emsp;使用 ConstantScoreQuery 或 BooleanClause.Occur.FILTER 操作符的 BooleanQuery 就构成了 Lucene 当前版本的过滤器。二者可以联合使用，也可单独使用，都起到过滤器的作用。

<br/><br/><br/><br/>

<a id="1"></a>
## 5.6.1 词项范围过滤 Term Range Filter ##


&emsp;&emsp;旧版本的 TermRangeFilter 是对特定域（field）内项（term）的范围进行过滤，与除去评分功能的 TermRangeQuery类似。注意，TermRangeFilter 处理的是文本域。新版本 Lucene 使用 ConstantScoreQuery 结合 BooleanClause.Occur.FILTER 操作符的 BooleanQuery 构造这种过滤器。

LUCENE-6583: FilteredQuery is deprecated and will be removed in 6.0. It should be replaced with a BooleanQuery which handle the query as a MUST clause and the filter as a FILTER clause. 

示例：程序5.12 使用 Term Range Filter 过滤文档标题

```java
public class FilterTest {
  private Directory directory;
  private DirectoryReader directoryReader;
  private IndexSearcher searcher;
  private Query allBooks;

  @Before
  public void setUp() throws Exception {
    allBooks = new MatchAllDocsQuery();
    //dir = TestUtil.getBookIndexDirectory();
    directory = FSDirectory.open(new File("../index").toPath());
    directoryReader = DirectoryReader.open(directory);
    searcher = new IndexSearcher(directoryReader);
  }

  @After
  public void tearDown() throws Exception {
    directoryReader.close();
    directory.close();
  }

  @Test
  public void testTermRangeFilter() throws Exception {
    //Filter filter = new TermRangeFilter("title2", "d", "j", true, true);
    TermRangeQuery termRangeQuery = TermRangeQuery.newStringRange(
            "title2", "d", "j", true, true);
    ConstantScoreQuery constantScoreQuery = new ConstantScoreQuery(termRangeQuery); ①
    long hitcount = TestUtil.hitCount(searcher, allBooks, constantScoreQuery);

    assertEquals(3, hitcount);
    System.out.println("hit count: " + hitcount);

  }
}
```

① 将 TermRangeQuery 封装为 ConstantScoreQuery，然后作为过滤器传递给 TestUtil.hitCount() 工具方法，由 TestUtil.hitCount() 方法进一步组合查询和过滤器，执行过滤和查询，这是两个操作。


其中 TestUtil.hitCount() 代码如下，它是单独使用 BooleanClause.Occur.FILTER 操作符构造过滤器的实例。

示例：程序5.13 TestUtil.hitCount(IndexSearcher searcher, Query query, ConstantScoreQuery filter)

```
public class TestUtil {
  public static long hitCount(IndexSearcher searcher, Query query, Query filter) throws IOException {
    BooleanQuery.Builder builder = new BooleanQuery.Builder();
    builder.add(query, BooleanClause.Occur.MUST);	①
    builder.add(filter, BooleanClause.Occur.FILTER);②

	BooleanQuery booleanQuery = builder.build();

    TopDocs topDocs = searcher.search(booleanQuery,10); ③
    System.out.println("topDocs.scoreDocs[] length: " + topDocs.scoreDocs.length);

    Document doc;
    for (ScoreDoc sd : topDocs.scoreDocs){
      doc = searcher.doc(sd.doc);
      String title2 = doc.get("title2");
      System.out.println("hit doc title2: " + title2);
	  System.out.println("hit doc score: " + sd.score);
    }

    return topDocs.totalHits.value;
  }
}
```

① 通过 BooleanClause.Occur.MUST 操作符为 BooleanQuery 添加必须的查询子句<br/>
② 通过 BooleanClause.Occur.FILTER 操作符为 BooleanQuery 添加过滤器<br/>
③ 由 IndexSearcher 执行真正的过滤查询

实际上，是通过 BooleanQuery 使用不同的子句操作符组装了查询和过滤器，然后经由 BooleanQuery 执行真正的查询。

<br/><br/><br/><br/>

<a id="2"></a>
## 5.6.2 数值范围过滤 Numeric Range Filter ##
&emsp;&emsp;旧版本 NumericRangeFilter 类负责过滤数值范围的文档。我们利用 IntPoint.newRangeQuery() 工厂方法创建一个int类型数值范围的查询，然后将其包装成ConstantScoreQuery 实例，最后把这个实例作为过滤器传递给 TestUtil.hitCount(IndexSearcher searcher, Query query, ConstantScoreQuery filter)，执行数值范围过滤查询。


```
  @Test
  public void testNumericDateFilter() throws Exception {
    // pub date of Lucene in Action, Second Edition and
    // JUnit in Action, Second Edition is May 2010

    Query query = IntPoint.newRangeQuery("pubmonth", 201001, 201006);
    ConstantScoreQuery constantScoreQuery = new ConstantScoreQuery(query);
    assertEquals(2, TestUtil.hitCount(searcher, allBooks, constantScoreQuery));
  }

```

<br/><br/><br/><br/>

<a id="3"></a>
## 5.6.3 DocValues 范围过滤 ##

&emsp;&emsp;旧版本 Lucene 的 FieldCache 机制提供了另一种范围过滤的选择。它基于 Lucene 的 field 缓存机制，因此可以在某些情况下带来系统性能的提升。但 FieldCache 机制已被新版本(Lucene 4.0)的 DocValues 机制所代替，因此，这里给出基于 DocValues 的范围过滤的示例代码。


```
  @Test
  public void testDocValuesRangeFilter() throws Exception {
//    Filter filter = FieldCacheRangeFilter.newStringRange("title2", "d", "j", true, true);

    Query query = SortedDocValuesField.newSlowRangeQuery("title2",
            new BytesRef("d"),
            new BytesRef("j"),
            true,
            true);
    ConstantScoreQuery filter = new ConstantScoreQuery(query);

    assertEquals(3, TestUtil.hitCount(searcher, allBooks, filter));

/*    filter = FieldCacheRangeFilter.newIntRange("pubmonth",
                                               201001,
                                               201006,
                                               true,
                                               true);*/

    Query pubmonth = IntPoint.newRangeQuery("pubmonth", 201001, 201006);
    Query dvQuery = NumericDocValuesField.newSlowRangeQuery("pubmonth", 201001, 201006);
    Query iodquery = new IndexOrDocValuesQuery(pubmonth, dvQuery);
    filter = new ConstantScoreQuery(iodquery);

    assertEquals(2, TestUtil.hitCount(searcher, allBooks, filter));
  }
```

<br/><br/><br/><br/>

<a id="4"></a>
## 5.6.4 过滤特定的词项 Filtering by specific terms ##

&emsp;&emsp;TermQuery 是 Lucene 最基本的查询类型，是对特定项(Term)的匹配查询。同样，通过 ConstantScoreQuery 的包装，可以构造出对特定 Term 的过滤类型。

示例：利用 TermQuery 过滤特定的项

```
  @Test
  public void testTemFilter() throws Exception {
    TermQuery categoryQuery =
       new TermQuery(new Term("category", "/technology/computers/programming"));

    ConstantScoreQuery filter = new ConstantScoreQuery(categoryQuery);

    assertEquals("expected 5 hits",
                 5,
                 TestUtil.hitCount(searcher, allBooks, filter));
  }

```

另外一种对特定项过滤的方法是通过 DocValues 机制构造 Term 过滤器，如下所示。

示例：

```
  @Test
  public void testDocValuesTermsFilter() throws Exception {

    Query dvQuery = SortedDocValuesField.newSlowExactQuery("category",
            new BytesRef("/technology/computers/programming"));

    ConstantScoreQuery filter = new ConstantScoreQuery(dvQuery);

    assertEquals("expected 5 hits",
            5, TestUtil.hitCount(searcher, allBooks, filter));
  }
```

<br/><br/><br/><br/>

<a id="5"></a>
## 5.6.5 使用 ConstantScoreQuery 类 ##

&emsp;&emsp;前面已经提到，ConstantScoreQuery 是一个包装类，可以使用任何类型的 Query 创建，只是如其类名所暗示， ConstantScoreQuery 查询返回的所有匹配文档的评分值(score)是相同的，值都为1，也就是说，它在查询过程中，不进行评分计算，因此，也就可以用它作为过滤器使用。

前面的示例，已经多次使用 ConstantScoreQuery 类来构造过滤器，只是它联合使用了 BooleanClause.Occur.FILTER 操作符，其实，单独使用 ConstantScoreQuery 完全可以，如下所示。

示例：使用 ConstantScoreQuery 类作为过滤器

```
  @Test
  public void testConstantScoreQueryFilter() throws Exception {
    TermQuery categoryQuery =
            new TermQuery(new Term("category", "/technology/computers/programming"));

    ConstantScoreQuery filter = new ConstantScoreQuery(categoryQuery);

    TopDocs topDocs = searcher.search(filter,10);

    System.out.println("hit count: " + topDocs.totalHits.value);
    System.out.println("topDocs.scoreDocs[] length: " + topDocs.scoreDocs.length);

    Document doc;
    for (ScoreDoc sd : topDocs.scoreDocs){
      doc =	searcher.doc(sd.doc);
      String title2 = doc.get("title2");
      System.out.println("hit doc title2: " + title2);
    }

    assertEquals("expected 5 hits",
            5,
            topDocs.totalHits.value);
  }
```
&emsp;&emsp;其中，传给 ConstantScoreQuery 构造器的 Query 可以是任何查询类型，本例为 TermQuery 类型的实例。

&emsp;&emsp;单独使用一个过滤器进行查询，结果意义不大，还是应该跟具体的查询联合使用，使查询结果限制在经过过滤的子集内。

示例: 利用 ConstantScoreQuery 类作为过滤器，联合使用具体的查询。

```
  @Test
  public void testConstantScoreQueryFilterAndQuery() throws Exception {
    TermQuery categoryQuery =
            new TermQuery(new Term("category", "/technology/computers/programming"));

    ConstantScoreQuery filter = new ConstantScoreQuery(categoryQuery);

    BooleanQuery.Builder builder = new BooleanQuery.Builder();
    builder.add(allBooks, BooleanClause.Occur.MUST);
    builder.add(filter, BooleanClause.Occur.MUST); ①
    BooleanQuery booleanQuery = builder.build();

    TopDocs topDocs = searcher.search(booleanQuery,10);

    System.out.println("hit count: " + topDocs.totalHits.value);
    System.out.println("topDocs.scoreDocs[] length: " + topDocs.scoreDocs.length);

    Document doc;
    for (ScoreDoc sd : topDocs.scoreDocs){
      doc =	searcher.doc(sd.doc);
      String title2 = doc.get("title2");
      System.out.println("hit doc title2: " + title2);
    }

    assertEquals("expected 5 hits",
            5,
            topDocs.totalHits.value);
  }
```

① builder.add(filter, BooleanClause.Occur.MUST); 虽然对过滤器 ConstantScoreQuery 使用的是 BooleanClause.Occur.MUST 子句操作符，但并不影响 filter 作为过滤器在 BooleanQuery 中的过滤作用，因为它对所有匹配文档的评分都是一样的值1，这些匹配文档构成了所有文档的一个子集，其它查询 allBooks 的结果只在这个子集中进行搜索匹配。

<br/><br/><br/><br/>

<a id="6"></a>
## 5.6.6 使用 SpanQuery 进行过滤 ##

&emsp;&emsp;也可以将 SpanQuery 及其子类作为参数传递给 ConstantScoreQuery 构造器来创建过滤器，使其保留 term 的跨度(spans)信息，这样就可以利用 SpanQuery 及其子类的特性来构造过滤器。当然，也可以直接使用 SpanQuery 以 BooleanClause.Occur.FILTER 操作符加入到 BooleanQuery 中实现 SpanQuery 特性的过滤。

示例：使用 SpanQuery 进行过滤

```
  @Test
  public void testSpanQueryFilter() throws Exception {
    SpanQuery subjectQuery = new SpanTermQuery(new Term("subject", "lucene"));
    ConstantScoreQuery filter = new ConstantScoreQuery(subjectQuery);

    assertEquals("only lucene in action",
                 1,
                 TestUtil.hitCount(searcher, allBooks, filter));
  }
```
示例：使用 SpanNearQuery 进行过滤

```
  @Test
  public void testSpanQueryFilter() throws Exception {
    SpanQuery[] quick_brown_dog =
        new SpanQuery[]{quick, brown, dog};
    SpanQuery snq = new SpanNearQuery(quick_brown_dog, 5, true);
   
    ConstantScoreQuery filter = new ConstantScoreQuery(snq);

    Query query = new MatchAllDocsQuery();

    BooleanQuery.Builder builder = new BooleanQuery.Builder();
    builder.add(query, BooleanClause.Occur.MUST);
    builder.add(filter, BooleanClause.Occur.FILTER);
    BooleanQuery booleanQuery = builder.build();

    TopDocs topDocs = searcher.search(booleanQuery,10);

    assertEquals(1, topDocs.totalHits.value);
    assertEquals("wrong doc", 0, topDocs.scoreDocs[0].doc);
  }

```

<br/><br/><br/><br/>

<a id="7"></a>
## 5.6.7 安全过滤器 Security filters ##

&emsp;&emsp;文档过滤的另一个应用场景是基于文档安全性来限制其匹配范围。在下面的例子中，假设各个文档都与其所有者关联在一起，这个关联信息是在索引过程中就已明确定义的。我们索引两个文档，它们都有名为 keywords 值为 info 的项(term)，但每个文档有不同的所有者(owner)，由文档的 "owner" 域定义，如下所示。

示例：创建具有所有者定义信息的索引

```
public class SecurityFilterTest {
  private Directory directory;
  private DirectoryReader reader;
  private IndexSearcher searcher;

  @Before
  public void setUp() throws Exception {
    directory = new RAMDirectory();
    IndexWriterConfig config = new IndexWriterConfig(new WhitespaceAnalyzer());
    IndexWriter writer = new IndexWriter(directory, config);

    Document document = new Document();                  
    document.add(new StringField("owner",          
                           "elwood",                     
                           Field.Store.YES));            
    document.add(new TextField("keywords",          
                           "elwood's sensitive info",    
                           Field.Store.YES));            

    writer.addDocument(document);

    document = new Document();                           
    document.add(new StringField("owner",           
                           "jake",                       
                           Field.Store.YES ));           

    document.add(new TextField("keywords",          
                           "jake's sensitive info",      
                           Field.Store.YES));            

    writer.addDocument(document);

    writer.close();

    reader = DirectoryReader.open(directory);
    searcher = new IndexSearcher(reader);
  }

  @After
  public void tearDown() throws Exception {
    reader.close();
    directory.close();
  }
}
```
&emsp;&emsp;两个文档，owner 域的值分别为 "elwood" 和 "jake"。

&emsp;&emsp;理所当然地，使用 TermQuery 在 keywords 域查询 "info"会得到全部的两个文档。但是，假设 Jake 正在使用我们这个程序的搜索功能，那么对于他来说，就应该只能搜索到他所拥有的文档。我们可以使用过滤器功能，将搜索空间限制在某个用户所拥有的文档范围内，从而轻松实现上述安全功能，如下代码所示。

示例：限制用户只能搜索到属于他自己的文档。

```
  @Test
  public void testSecurityFilter() throws Exception {
    TermQuery query = new TermQuery(new Term("keywords", "info"));  ①

    assertEquals("Both documents match",               
                 2,                                 
                 TestUtil.hitCount(searcher, query));  

    ConstantScoreQuery jakeFilter = new ConstantScoreQuery(new TermQuery(new Term("owner", "jake"))); ②

    BooleanQuery.Builder builder = new BooleanQuery.Builder();
    builder.add(query, BooleanClause.Occur.MUST);
    builder.add(jakeFilter, BooleanClause.Occur.FILTER); ③
    BooleanQuery booleanQuery = builder.build();

    TopDocs hits = searcher.search(booleanQuery, 10); ④ 

    assertEquals(1, hits.totalHits.value);                      
    assertEquals("elwood is safe",                              
                 "jake's sensitive info",                               
                  searcher.doc(hits.scoreDocs[0].doc).get("keywords"));
  }
```

① 针对 keywords 域 "info" 项的查询<br/>
② 构造过滤器，把文档的搜索范围限制在 jake 所有者的文档范围内<br/>
③ 将查询子句和过滤子句连接起来构建布尔查询<br/>
④ 执行过滤查询，并验证查询结果<br/>


<br/><br/><br/><br/>

<a id="8"></a>
## 5.6.8 使用 BooleanQuery 类过滤 ##

&emsp;&emsp;一直都在用。只是，如果要连接的过滤器是一般的 Query，应该使用操作符 BooleanClause.Occur.FILTER，如果是 ConstantScoreQuery 作为过滤器，使用 BooleanClause.Occur.FILTER 和 BooleanClause.Occur.MUST 效果是一样的，因为 ConstantScoreQuery 已经将所有匹配文档的评分因子设定为常量值1，它不会对整个 BooleanQuery 搜索结果的评分产生任何影响。BooleanClause.Occur.FILTER 和 BooleanClause.Occur.MUST 操作符在逻辑语义上都是逻辑“与”，即 “AND”。

示例：使用 BooleanQuery 类过滤

```
  @Test
  public void testFilterAlternative() throws Exception {
    TermQuery categoryQuery =
       new TermQuery(new Term("category", "/philosophy/eastern"));

    BooleanQuery.Builder builder = new BooleanQuery.Builder();
    builder.add(allBooks, BooleanClause.Occur.MUST);
    builder.add(categoryQuery, BooleanClause.Occur.MUST);
    BooleanQuery constrainedQuery = builder.build();

    assertEquals("only tao te ching",
                 1,
                 TestUtil.hitCount(searcher, constrainedQuery));
  }
```

<br/><br/><br/><br/>

<a id="9"></a>
## 5.6.9 使用 PrefixQuery 类过滤 ##

&emsp;&emsp;PrefixQuery 查询，会对包含特殊前缀开始的 term 的文档进行匹配，用它作为过滤器，可以将搜索范围限制在某个指定类别的所有书籍中。

示例：使用 BooleanQuery 类过滤匹配文档

```
  @Test
  public void testPrefixQueryFilter() throws Exception {
    PrefixQuery prefixFilter = new PrefixQuery(
                            new Term("category",
                                     "/technology/computers"));
    assertEquals("only /technology/computers/* books",
                 8,
                 TestUtil.hitCount(searcher,
                                   allBooks,
                                   prefixFilter));
  }

```

