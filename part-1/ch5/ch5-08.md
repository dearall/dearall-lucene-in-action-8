## 5.6 针对多索引的搜索 Searching across multiple Lucene indexes ##

&emsp;&emsp;某些应用程序需要保持多个分离的 Lucene 索引，但又需要在搜索过程中能够针对这几个索引的所有搜索结果合并输出。有时候，导致这类分离索引出现可能是为了方便程序运行或管理上的原因，例如，如果不同的用户或组织为不同的文档集合创建了不同的索引，就会导致多个分离索引的出现。有时这种情况的出现是为了增大文档容量，例如，一个新闻网站可能每月新创建一个索引，然后在搜索时指定该月份对应的索引即可。

&emsp;&emsp;处于这些原因，Lucene 提供了 MultiReader 实用类来针对多索引进行搜索。MultiReader 的构造函数是一个可变参数列表。通过 MultiReader(IndexReader… subReaders)可以接收多个 IndexReader 实例，然后再合并成一个 IndexSearcher，这样就可以做到多索引文件的合并搜索。三个重载构造器主要参数类似，如下：

MultiReader(IndexReader... subReaders)
MultiReader(IndexReader[] subReaders, boolean closeSubReaders)
MultiReader(IndexReader[] subReaders, Comparator<IndexReader> subReadersSorter, boolean closeSubReaders)


示例：

```
public class MultiReaderSearchTest {
  private Analyzer analyzer = new WhitespaceAnalyzer();
  private IndexWriterConfig aIndexWriterConfig = new IndexWriterConfig(analyzer);
  private IndexWriterConfig bIndexWriterConfig = new IndexWriterConfig(analyzer);
  private Directory aTOmDirectory;
  private Directory nTOzDirectory;

  private IndexSearcher[] searchers;

  @Before
  public void setUp() throws Exception {

    String[] animals = { "aardvark", "beaver", "coati",
                       "dog", "elephant", "frog", "gila monster",
                       "horse", "iguana", "javelina", "kangaroo",
                       "lemur", "moose", "nematode", "orca",
                       "python", "quokka", "rat", "scorpion",
                       "tarantula", "uromastyx", "vicuna",
                       "walrus", "xiphias", "yak", "zebra"};


    aTOmDirectory = new RAMDirectory();
    nTOzDirectory = new RAMDirectory();

    IndexWriter aTOmWriter = new IndexWriter(aTOmDirectory, aIndexWriterConfig);
    IndexWriter nTOzWriter = new IndexWriter(nTOzDirectory, bIndexWriterConfig);

    for (int i=animals.length - 1; i >= 0; i--) {
      Document doc = new Document();
      String animal = animals[i];

      doc.add(new StringField("animal", animal, Field.Store.YES));
      if (animal.charAt(0) < 'n') {
        aTOmWriter.addDocument(doc);
      } else {                                       
        nTOzWriter.addDocument(doc);
      }
    }

    aTOmWriter.close();
    nTOzWriter.close();
  }

  @After
  public void tearDown() throws Exception {
    aTOmDirectory.close();
    nTOzDirectory.close();
  }

  @Test
  public void testMultiReaderSearch() throws Exception {
    IndexReader aIndexReader = DirectoryReader.open(aTOmDirectory);
    IndexReader nIndexReader = DirectoryReader.open(nTOzDirectory);
    MultiReader multiReader = new MultiReader(aIndexReader, nIndexReader);

    IndexSearcher indexSearcher = new IndexSearcher(multiReader);
    TermRangeQuery query = new TermRangeQuery("animal",
            new BytesRef("h"),
            new BytesRef("t"),
            true,
            true);
    TopDocs animal = indexSearcher.search(query,20);

    assertEquals(12, animal.totalHits.value);
    System.out.println("totalHits: " + animal.totalHits.value);

    ScoreDoc[] scoreDocs = animal.scoreDocs;
    System.out.println("scoreDocs length: " + scoreDocs.length);

    for (ScoreDoc sd : scoreDocs) {
      System.out.println("docId: "+sd.doc + "  doc: " + indexSearcher.doc(sd.doc));
    }

    multiReader.close();
  }
}
```


