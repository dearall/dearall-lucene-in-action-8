## 2.6 Field 类语法糖子类 Field's sugar subclasses ##

&emsp;&emsp;本节是上一节的延续，我们继续探讨 Field 的特性。从 2.3 节可以看出，Lucene 通过 FieldType 为 Field 类提供了非常丰富的索引选项，使我们可以创建出具有各种选项类型的 Field 对象，以满足应用对索引数据的需求。但这种灵活性也使得创建 Field 对象变得很繁琐，每当创建一个 Field 时，需要首先创建一个 FieldType 对象，然后设置它的各种选项，继而调用 FieldType.freeze() 方法来冻结类型选项，使其不会在其他地方更改这个域类型的选项，最后调用 Field 的构造器创建 Field 对象。这样的过程太麻烦了，为了简化 Field 的创建，Lucene 提供了丰富的 Field 子类，用某些内置预定义的 FieldType 对象来创建具有特定需求和特征的 Field 实例。

&emsp;&emsp;之所以称本节所讨论的 Field 子类为语法糖子类，是因为这些类虽然继承自 Field 类，但它们并没有引入新的逻辑，而是通过预设置某些域类型选项，然后调用该域类型的 freeze() 方法，将该域类型冻结，最后作为 Field 类的域类型传递给 Field 类构造器，从而定义了具有某些固定的域类型选项的域，方便我们直接拿来使用，而不需要在构造 Field 实例之前，自己动手对每个域的域类型进行设置，就如本节之前的那些示例代码所示。

&emsp;&emsp;除了使用 Lucene 为我们提供的这些预定义的 Field 子类，我们也可以按照这种方法来建立符合应用需求的自定义的子类，以满足自身的需要。或者使用之前原生的方法，为之提供 FieldType 实例的方法创建 Field 实例。

&emsp;&emsp;下面让我们分别讨论每种子类的定义和适用于它的应用场景。

<br/><br/>
<a id="1"></a>
## 2.6.1 TextField 子类 TextField sugar subclass ##

&emsp;&emsp;TextField 类表示一个进行索引和分词的域，没有词向量 term vectors 存储。这种域是全文检索中使用最频繁、最普通的文本域类型，适用于 'body' 这样包含有大量文本内容的域。它的值类型是之前介绍过的文本数据，以下是它的三个文本值类型构造器：
- **TextField(String name, String value, Field.Store store)** 使用 String 类型值创建 TextField 实例。通过 Field.Store 参数指定该域是存储域还是非存储域。
- **TextField(String name, Reader reader)** 使用 Reader 类型值创建非存储 TextField 实例。
- **TextField(String name, TokenStream stream)** 使用 TokenStream 类型值创建非存储 TextField 实例。

&emsp;&emsp;看得出，三个构造器已经没有了域类型 FieldType 参数。因为在 TextField 类内部，已经预定义好了静态的、final 修饰的 FieldType 实例，并在 TextField 类的静态代码块中进行了选项设置，然后调用其 freeze() 方法冻结域类型选项设置。

```
/** A field that is indexed and tokenized, without term
 *  vectors.  For example this would be used on a 'body'
 *  field, that contains the bulk of a document's text. */

public final class TextField extends Field {

  /** Indexed, tokenized, not stored. */
  public static final FieldType TYPE_NOT_STORED = new FieldType();

  /** Indexed, tokenized, stored. */
  public static final FieldType TYPE_STORED = new FieldType();

  static {
    TYPE_NOT_STORED.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
    TYPE_NOT_STORED.setTokenized(true);
    TYPE_NOT_STORED.freeze();

    TYPE_STORED.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
    TYPE_STORED.setTokenized(true);
    TYPE_STORED.setStored(true);
    TYPE_STORED.freeze();
  }
}
```

&emsp;&emsp;TextField 类内部定义了两个 FieldType 实例，分别对应于存储的域和不存储的域。是为了在使用 TextField(String name, String value, Field.Store store) 构造器时，根据提供的 Field.Store 枚举参数选择使用不同的域类型进行实例构建。两个域类型的索引选项都是 DOCS_AND_FREQS_AND_POSITIONS，这是全文检索的标准索引方式：支持完全评分计算和位置相关查询类型。

<br/><br/>
<a id="2"></a>
## 2.6.2 StringField 子类 StringField sugar subclass ##

&emsp;&emsp;这是另一表示文本值类型的域，表示一个索引但不分词的文本域，它把整个字符串值作为一个词元进行索引。

>JavaDoc: A field that is indexed but not tokenized: the entire String value is indexed as a single token. 

&emsp;&emsp;这种域可用于类似 'country'、'id'、'url'、'email'、'md5' 这样作为一个整体进行索引的文本域。如果要对该域进行排序，例如要对 'country' 域按国家名排序，或者对 'id'域按序号大小进行排序，另外再向该文档添加一个 SortedDocValuesField 类型的域。

>JavaDoc: If you also need to sort on this field, separately add a SortedDocValuesField to your document.

下面是 StringField 类的两个文本值类型构造器：

- **StringField(String name, BytesRef value, Field.Store stored)** 创建一个二进制的文本域，把提供的二进制值（BytesRef）作为一个单独的词元 token 进行索引。 
- **StringField(String name, String value, Field.Store stored)** 使用 String 类型值创建一个文本类型域，把提供的字符串值作为一个单独的词元 token 进行索引。 

&emsp;&emsp;与 TextField 类相似，这两个构造器都有一个 Field.Store 型参数，用于控制该域加入索引时，是存储该域的原始数据。

&emsp;&emsp;两个构造器的唯一区别是传递给 Field 的值类型。String 类型值很好理解，使用 Java 原生的字符串类型表示一段文本数据。

&emsp;&emsp;BytesRef 类则是 Lucene 提供的一种表示二进制数据类型的工具类。表示一个 byte[] 数组类型的数据的一部分，称为切片（slice），由 int offset, int length 这两个属性定义切片在原始 byte[] 数组中的起始位置和切片长度。对 go 语言了解的人对这个数据结构并不陌生，BytesRef 与 go 的 slice 数据类型具有相同的语义，一种简单而快速的动态数组结构。只是 go 的 slice 底层数组元素类型更加丰富，可以表示任何 go 语言支持类型。而 BytesRef 底层数组元素类型被限定为 byte 类型，是固定的 byte[] 数组类型。BytesRef 可以表示任意的二进制类型数据，包括经过编码的数值类型和字符串类型。当 BytesRef 表示字符串类型时，它的底层 byte[] 数据表示的是 UTF-8 编码的字符串数据（UTF8 bytes），这与 Java 原生字符串类型 String 使用的字符串编码不同。Java 原生 String 类型使用 Java 变体的 UTF-16 编码，因此二者之间不能直接通用。

&emsp;&emsp;在使用 Java 原生的 String 类型或字符串文本字面量创建 BytesRef 对象时，在 BytesRef 构造器内部进行了 UTF-16 到 UTF-8 的编码转换：

```
  /**
   * Initialize the byte[] from the UTF8 bytes
   * for the provided String.  
   * 
   * @param text This must be well-formed
   * unicode text, with no unpaired surrogates.
   */
  public BytesRef(CharSequence text) {
    this(new byte[UnicodeUtil.maxUTF8Length(text.length())]);
    length = UnicodeUtil.UTF16toUTF8(text, 0, text.length(), bytes);
  }
```

&emsp;&emsp;而在将 BytesRef 对象表示的字符串转换为 Java 原生 String 类型时，则需要调用 BytesRef 提供的 utf8ToString() 方法。在 utf8ToString() 方法内部，进行的是 UTF-8 到 UTF-16 的编码转换：

```
  /** Interprets stored bytes as UTF8 bytes, returning the
   *  resulting string */
  public String utf8ToString() {
    final char[] ref = new char[length];
    final int len = UnicodeUtil.UTF8toUTF16(bytes, offset, length, ref);
    return new String(ref, 0, len);
  }
```

除非特别说明，Lucene 使用 BytesRef 类表示索引数据库中经 UTF8 编码的词项 term。
>JavaDoc: Unless otherwise noted, Lucene uses this class to represent terms that are encoded as UTF8 bytes in the index.

&emsp;&emsp;StringField 类的第一个构造器 StringField(String name, BytesRef value, Field.Store stored) 就是使用 BytesRef 表示文本值来构建一个新的域。

&emsp;&emsp;在 StringField 类内部，也预定义了静态的、final 修饰的 FieldType 实例，并在类的静态代码块中进行了选项设置，然后调用其 freeze() 方法冻结域类型选项设置，防止其它代码改变对该域类型的配置。

```
  /** Indexed, not tokenized, omits norms, indexes
   *  DOCS_ONLY, not stored. */
  public static final FieldType TYPE_NOT_STORED = new FieldType();

  /** Indexed, not tokenized, omits norms, indexes
   *  DOCS_ONLY, stored */
  public static final FieldType TYPE_STORED = new FieldType();

  static {
    TYPE_NOT_STORED.setOmitNorms(true);
    TYPE_NOT_STORED.setIndexOptions(IndexOptions.DOCS);
    TYPE_NOT_STORED.setTokenized(false);
    TYPE_NOT_STORED.freeze();

    TYPE_STORED.setOmitNorms(true);
    TYPE_STORED.setIndexOptions(IndexOptions.DOCS);
    TYPE_STORED.setStored(true);
    TYPE_STORED.setTokenized(false);
    TYPE_STORED.freeze();
  }
}
```

&emsp;&emsp;与 TextField 类似，内部定义了两个 FieldType 实例，分别对应于存储的域和不存储的域。根据提供的 Field.Store 枚举参数选择使用不同的域类型进行实例构建。两个域类型的索引选项都是 DOCS，这是把整个文本值作为单一词元进行索引的定义方式。setTokenized(false) 表明不对域值进行分词处理。setOmitNorms(true) 说明忽略该域 Norms 归一化因子的计算和存储。

<br/><br/>
<a id="3"></a>
## 2.6.3 StoredField 子类 StoredField sugar subclass ##

&emsp;&emsp;StoredField 是一个简单的域，表示一个域存储到索引中，这样，就可以通过 IndexSearcher.doc(int) 和 document(int docID, StoredFieldVisitor visitor) 取回域和其中包含的原始值。

&emsp;&emsp;StoredField 表示的域虽然简单，但它提供了非常丰富的重载构造器来接收各种类型的值作为存储域的数据来源。并且，除了使用内置的域类型来构造实例外，StoredField 还提供了使用自定义选项配置的 FieldType 来创建实例的能力，是其具有很大的灵活性。

先看看内置域类型选项的配置：

```
  /**
   * Type for a stored-only field.
   */
  public final static FieldType TYPE;
  static {
    TYPE = new FieldType();
    TYPE.setStored(true);
    TYPE.freeze();
  }
```

内置域类型选项的配置非常简单，只是开启了存储选项配置 TYPE.setStored(true)，其它选项保持默认值。

下面是 StoredField 提供的构造器：
- StoredField(String name, byte[] value) 通过给定的 byte[] 二进制值创建存储域。
- StoredField(String name, byte[] value, int offset, int length) 通过给定的 byte[] 二进制值创建存储域。
- StoredField(String name, BytesRef value) 通过给定的 BytesRef 二进制值创建存储域。
- StoredField(String name, BytesRef bytes, FieldType type) 通过给定的 BytesRef 二进制值创建存储域，提供自定义的 FieldType。
- StoredField(String name, CharSequence value, FieldType type) 通过给定的字符序列作为域值创建存储域，提供自定义 FieldType。
- StoredField(String name, double value) 通过给定的 double 类型值创建存储域。
- StoredField(String name, FieldType type) protected: 高级用法，用于子类继承，通过 set*** 方法传递值。
- StoredField(String name, float value) 通过给定的 float 类型值创建存储域。
- StoredField(String name, int value) 通过给定的 int 类型值创建存储域。
- StoredField(String name, long value) 通过给定的 long 类型值创建存储域。
- StoredField(String name, String value) 通过给定的 String 类型值创建存储域。
- StoredField(String name, String value, FieldType type) 通过给定的 String 类型值创建存储域，提供自定义 FieldType。

&emsp;&emsp;可以看出，这里 StoredField 支持的值类型非常丰富，几乎涵盖了日常应用中所有的简单数据类型，也就是说这些值类型的域都可以存储到索引中。但也有两个值类型排除在外：Reader 和 TokenStream 类型，也就是说，这两种值类型的域不支持把域存储到索引中。



<br/><br/>
<a id="4"></a>
## 2.6.4 IntPoint 子类 ##

&emsp;&emsp;有两个常见的场景使得索引数字非常重要。一种场景是数字嵌入在要索引的文本中，而且要确保这些数字在索引时被保留，并被当做普通的词元，这样之后可以在搜索时作为普通词元使用。举个例子，索引的文档中可能包含这样的语句 “Be sure to include Form 1099 in your tax return”：我们想能够搜索数字 1099，就像通过搜索短语 “tax return” 那样检索到包含准确数字的文档。

&emsp;&emsp;要做到这一点，简单地选择一个不丢弃数字的分析器就可以达到目的。WhitespaceAnalyzer 和StandardAnalyzer 都可以满足需要。在把 “Be sure to include Form 1099 in your tax return” 语句输入给这样的分析器后，它们会抽取 1099 作为词元传递给索引，这样就允许之后直接搜索 1099 这个词项。相反，SimpleAnalyzer 和 StopAnalyzer 分析器会丢弃词元流中的数字，这就意味着，搜索 1099 不会匹配到任何文档。

&emsp;&emsp;另一个索引数字的场景是，有一个域，含有一个单一的数字，我们想把它作为一个数字进行索引，之后用它进行精确匹配（值相等）、范围搜索、以及排序。举个例子，索引零售目录里的商品，每种商品都有一个数字型的价格，我们要使客户能够限定一定的价格范围来对商品进行搜索。

&emsp;&emsp;Lucene 的早期版本，只能对文本型的词项进行处理，处理起来很麻烦。到了 2.9 版本，Lucene 引入了容易使用的 NumericField 类，使用其 set<Type>Value 方法对数值数据进行索引。

&emsp;&emsp;到了 Lucene 4.0 版，随着 IndexableField 接口的引入，Lucene 摈弃了传统 Field 类型的定义，通过 IndexableField 接口和 FieldType 类重新定义了 Field 类型，并移除了 NumericField 类的定义，加入了 IntField、LongField、FloatField、DoubleField 表示数值的域类型，以及相应的 DocValues 数值型正向索引域类型。

&emsp;&emsp;从 6.0 版开始，Lucene 引入了 PointValues 数值型数据概念，用于表示地理位置信息的索引和查询操作数据，地理信息经常表示为二维或三维空间的数据，但这种数据类型也可以表示一维的单一数值数据，或者更多维数空间的数据。得益于 PointValues 的优秀设计，它在多维数值和多维数值区间的索引和搜索操作上表现得非常出色，并且可以将任何数量维度的数值统一为一种实现。因此，从 Lucene 6.0 开始，PointValues 已成为数值型数据事实上的标准，所有数值型域都以 PointValues 作为标准实现。由 PointValues 引入 IntPoint、LongPoint、FloatPoint、DoublePoint 多维数值域类型。而传统数值型域类型 DoubleField、FloatField、IntField、LongField 被更名为带有 Legacy 前缀的类名，并被标注为废弃内容 @Deprecated，最终在 Lucene 7.0 版被移除。

&emsp;&emsp;2.4.7 节讨论了 PointValues 的概念和它支持的类型选项，它是新版 Lucene 索引数值型数据的标准实现。IntPoint 类表示一个整型数值索引的域，它的值类型是 int[]，意在表示一个多维空间的点，例如，要表示一个三维空间的点，则数组的长度为 3，IntPoint 中有 3 个数值分别表示该点在每一个维度上的数值 [X, Y, Z]。特别地，当维数为 1 时，IntPoint 就表示一个单一数值的域。

&emsp;&emsp;IntPoint 类型的域一般用作快速的范围过滤器（An indexed int field for fast range filters）。

&emsp;&emsp;如果要存储该域的值，另外添加一个 StoredField 类型的域。

&emsp;&emsp;IntPoint 类型域在搜索多维图形或者在一定范围内搜索时非常高效。在一个文档中，这种类型的同一个域拥有多个值是允许的。

为了清楚了解 IntPoint 类的内部逻辑，我们直接深入到它的构造器代码：

```
  /** Creates a new IntPoint, indexing the
   *  provided N-dimensional int point.
   *
   *  @param name field name
   *  @param point int[] value
   *  @throws IllegalArgumentException if the field name or value is null.
   */
  public IntPoint(String name, int... point) {
    super(name, pack(point), getType(point.length));
  }
```

&emsp;&emsp;数据参数类型是 int... point，参数数量可变，用于表示任意维度的 int 型数值。这里的 super 代表 IntPoint 的直接父类 Field。pack(point) 是 IntPoint 类静态工具方法，用于对 int[] 型数据 point 进行二进制编码处理，返回 BytesRef 型数据。getType(point.length) 也是一个静态工具方法，其中 point.length 表示 int[] 数组的长度，也就是 IntPoint 表示的一个 n 维空间的点数据的维度数， getType() 方法的代码如下：

```
  private static FieldType getType(int numDims) {
    FieldType type = new FieldType();
    type.setDimensions(numDims, Integer.BYTES);
    type.freeze();
    return type;
  }
```

在上述代码中，FieldType 实例设置了维度选项，type.setDimensions(numDims, Integer.BYTES); 第一个参数是 IntPoint 点数据的维数，即由构造器传入的数值数组的长度。第二个参数 Integer.BYTES 则是整型数据对象 Integer 占用的内存字节数，由 Java 语言定义的常量，值为 4。

这样，就搞清楚定义 IntPoint 类型的构造逻辑，它表示一个由多维的数据表示的点建立的索引域，每一维由一个 int 型数据表示。当维数为 1 时，它表示一个 int 型数值域。

<br/><br/>
<a id="5"></a>
## 2.6.5 LongPoint 子类 ##

&emsp;&emsp;与 IntPoint 类似，LongPoint 也是 PointValues 实现，只是它的值类型由 int[] 变成了 long[]，意在表示一个多维空间的点，每个点由多个维度的 long 型数值表示。当维数为 1 时，LongPoint 就表示一个单一的数值型域。与 IntPoint 一样，LongPoint 类型的域也用作快速的范围过滤器（An indexed long field for fast range filters）。

&emsp;&emsp;如果要存储该域的值，另外添加一个 StoredField 类型的域。

&emsp;&emsp;LongPoint 类型域在搜索多维图形或者在一定范围内搜索时非常高效。在一个文档中，这种类型的同一个域拥有多个值是允许的。

查看 LongPoint 构造器代码：

```
  /** Creates a new LongPoint, indexing the
   *  provided N-dimensional long point.
   *
   *  @param name field name
   *  @param point long[] value
   *  @throws IllegalArgumentException if the field name or value is null.
   */
  public LongPoint(String name, long... point) {
    super(name, pack(point), getType(point.length));
  }  
```

看得出，LongPoint 构造器代码与 IntPoint 一样，只是数据参数类型是 long... point，参数数量可变，用于表示任意维度的 long 型数值。

getType() 方法代码：

```
  private static FieldType getType(int numDims) {
    FieldType type = new FieldType();
    type.setDimensions(numDims, Long.BYTES);
    type.freeze();
    return type;
  }
```
FieldType 实例设置了维度选项，type.setDimensions(numDims, Long.BYTES); 第一个参数是 LongPoint 点数据的维数，即由构造器传入的数值数组的长度。第二个参数 Long.BYTES 是 Long 型数据对象占用的内存字节数，由 Java 语言定义的常量，值为 8。

&emsp;&emsp;LongPoint 表示一个由多维的数据表示的点建立的索引域，每一维由一个 long 型数据表示。当维数为 1 时，它表示一个 long 型数值域。

<br/><br/>
<a id="6"></a>
## 2.6.6 FloatPoint 子类 ##

&emsp;&emsp;与 IntPoint 和 LongPoint 类似，FloatPoint 域也由 PointValues 实现，只是它的值类型是 float[]，意在表示一个多维空间的点，每个点由多个维度的 float 型数值表示。当维数为 1 时，FloatPoint 表示一个单一的数值型域。与 IntPoint 一样，FloatPoint 类型的域也用作快速的范围过滤器（An indexed float field for fast range filters）。

&emsp;&emsp;如果要存储该域的值，另外添加一个 StoredField 类型的域。

&emsp;&emsp;FloatPoint 类型域在搜索多维图形或者表示范围的数值时非常高效。在一个文档中，这种类型的同一个域拥有多个值是允许的。

查看 FloatPoint 构造器代码：

```
  /** Creates a new FloatPoint, indexing the
   *  provided N-dimensional float point.
   *
   *  @param name field name
   *  @param point float[] value
   *  @throws IllegalArgumentException if the field name or value is null.
   */
  public FloatPoint(String name, float... point) {
    super(name, pack(point), getType(point.length));
  }
```
看得出，FloatPoint 构造器代码与 IntPoint 一样，只是数据参数类型是 float... point，参数数量可变，用于表示任意维度的浮点数值。

getType() 方法代码：

```
  private static FieldType getType(int numDims) {
    FieldType type = new FieldType();
    type.setDimensions(numDims, Float.BYTES);
    type.freeze();
    return type;
  }

```

FieldType 实例设置了维度选项，type.setDimensions(numDims, Float.BYTES); 第一个参数是 FloatPoint 点数据的维数，即由构造器传入的数值数组的长度。第二个参数 Float.BYTES 是 Float 型数据对象占用的内存字节数，由 Java 语言定义的常量，值为 4。

&emsp;&emsp;FloatPoint 表示一个由多维的数据表示的点建立的索引域，每一维由一个 float 型数据表示。当维数为 1 时，它表示一个 float 型数值域。

<br/><br/>
<a id="7"></a>
## 2.6.7 DoublePoint 子类 ##

&emsp;&emsp;与 FloatPoint 类似，DoublePoint 域也由 PointValues 实现，只是它的值类型是 double[]，意在表示一个多维空间的点，每个点由多个维度的  double 型数值表示。当维数为 1 时，DoublePoint 表示一个单一的数值型域。与 IntPoint 一样，DoublePoint 类型的域也用作快速的范围过滤器（An indexed double field for fast range filters）。

&emsp;&emsp;如果要存储该域的值，另外添加一个 StoredField 类型的域。

&emsp;&emsp;DoublePoint 类型域在搜索多维图形或者在一定范围内搜索时非常高效。在一个文档中，这种类型的同一个域拥有多个值是允许的。

查看 DoublePoint 构造器代码：

```
  /** Creates a new DoublePoint, indexing the
   *  provided N-dimensional double point.
   *
   *  @param name field name
   *  @param point double[] value
   *  @throws IllegalArgumentException if the field name or value is null.
   */
  public DoublePoint(String name, double... point) {
    super(name, pack(point), getType(point.length));
  }
```

DoublePoint 构造器代码与 FloatPoint 一样，只是数据参数类型是 double... point，参数数量可变，用于表示任意维度的浮点数值。

getType() 方法代码：

```
  private static FieldType getType(int numDims) {
    FieldType type = new FieldType();
    type.setDimensions(numDims, Double.BYTES);
    type.freeze();
    return type;
  }
```

FieldType 实例设置了维度选项，type.setDimensions(numDims, Double.BYTES); 第一个参数是 DoublePoint 点数据的维数，即由构造器传入的数值数组的长度。第二个参数 Double.BYTES 是 Double 型数据对象占用的内存字节数，由 Java 语言定义的常量，值为 8。

&emsp;&emsp;DoublePoint 表示一个由多维的数据表示的点建立的索引域，每一维由一个 double 型数据表示。当维数为 1 时，它表示一个 dobule 型数值域。

<br/><br/>
<a id="8"></a>
## 2.6.8 BinaryPoint 子类 ##

&emsp;&emsp;BinaryPoint 是另外一个 PointValues 实现的多维数值型域，它的特点是每一维的数值不是固定的 int, long, float 或 double 类型数据，而是不确定长度的 byte[] 类型，这使 BinaryPoint 类型的域具有更强的通用性，可以表示占用任意字节长度的数据，比如 1 字节，2 字节，16 字节，等等都可以用 BinaryPoint 来表示。

&emsp;&emsp;BinaryPoint 类型的域也用于快速的范围过滤器（An indexed binary field for fast range filters）。

&emsp;&emsp;如果要存储该域的值，另外添加一个 StoredField 类型的域。

&emsp;&emsp;BinaryPoint 类型域在搜索多维图形或者在一定范围内搜索时非常高效。在一个文档中，这种类型的同一个域拥有多个值是允许的。

探索 BinaryPoint 构造器代码：

```
  /** General purpose API: creates a new BinaryPoint, indexing the
   *  provided N-dimensional binary point.
   *
   *  @param name field name
   *  @param point byte[][] value
   *  @throws IllegalArgumentException if the field name or value is null.
   */
  public BinaryPoint(String name, byte[]... point) {
    super(name, pack(point), getType(point));
  }
```

&emsp;&emsp;BinaryPoint 构造器数据参数类型是 byte[]... point，参数数量可变，用于表示任意维度的 byte[] 数值。与上一节探讨的 DoublePoint 构造器的数据参数不太一样，DoublePoint 每一维上的数据是固定的 double 类型，占用字节数是固定的 8，而 BinaryPoint 是 byte[] 类型，每一维数据占用的字节数可以是任意长度。当然 BinaryPoint 实例创建完成之后，字节长度也就是确定的了，不能中途再改变。

&emsp;&emsp;这里有趣的是 getType(point) 方法，它的参数是将整个数据参数传递给了 getType() 方法，而不像前面介绍的 ***Point 类型，直接传递点数据的维数。

我们来探索一下这个 getType() 的代码：

```
  private static FieldType getType(byte[][] point) {
    if (point == null) {
      throw new IllegalArgumentException("point must not be null");
    }
    if (point.length == 0) {
      throw new IllegalArgumentException("point must not be 0 dimensions");
    }
    int bytesPerDim = -1;
    for(int i=0;i<point.length;i++) {
      byte[] oneDim = point[i];
      if (oneDim == null) {
        throw new IllegalArgumentException("point must not have null values");
      }
      if (oneDim.length == 0) {
        throw new IllegalArgumentException("point must not have 0-length values");
      }
      if (bytesPerDim == -1) {
        bytesPerDim = oneDim.length;
      } else if (bytesPerDim != oneDim.length) {
        throw new IllegalArgumentException("all dimensions must have same bytes length; got " + bytesPerDim + " and " + oneDim.length);
      }
    }
    return getType(point.length, bytesPerDim);
  }

```

这段代码的含义是获取多维数据 byte[][] point 中每一维 byte[] 数据占用的字节数，并且确定所有维度上的数据占用相同的字节数，否则判定该数据为非法参数，抛出异常。最后代码调用另外一个我们比较熟悉的 getType(point.length, bytesPerDim) 方法返回 FieldType 对象。

再看一下最后调用的 getType() 代码：

```
  private static FieldType getType(int numDims, int bytesPerDim) {
    FieldType type = new FieldType();
    type.setDimensions(numDims, bytesPerDim);
    type.freeze();
    return type;
  }
```
这段代码很熟悉，FieldType 实例设置了维度选项，type.setDimensions(numDims, bytesPerDim); 第一个参数是 BinaryPoint 点数据的维度，即由构造器传入的 byte[]...point 数据外围数组的长度。第二个参数是由之前那个 FieldType getType(byte[][] point) 方法获取的每一维数据占用的字节数 bytesPerDim，而不是像 DoublePoint 类型那样，每一维上占用固定的 8 字节数据。

&emsp;&emsp;BinaryPoint 表示一个由多维的数据表示的点建立的索引域，每一维由一个 byte[] 型数据表示，并且所有维度上的数据必须具有固定的字节数。

再看一下 pack(point) 方法的实现：

```

  private static BytesRef pack(byte[]... point) {
    if (point == null) {
      throw new IllegalArgumentException("point must not be null");
    }
    if (point.length == 0) {
      throw new IllegalArgumentException("point must not be 0 dimensions");
    }
    if (point.length == 1) {
      return new BytesRef(point[0]);
    }
    int bytesPerDim = -1;
    for(byte[] dim : point) {
      if (dim == null) {
        throw new IllegalArgumentException("point must not have null values");
      }
      if (bytesPerDim == -1) {
        if (dim.length == 0) {
          throw new IllegalArgumentException("point must not have 0-length values");
        }
        bytesPerDim = dim.length;
      } else if (dim.length != bytesPerDim) {
        throw new IllegalArgumentException("all dimensions must have same bytes length; got " + bytesPerDim + " and " + dim.length);
      }
    }
    byte[] packed = new byte[bytesPerDim*point.length];
    for(int i=0;i<point.length;i++) {
      System.arraycopy(point[i], 0, packed, i*bytesPerDim, bytesPerDim);
    }
    return new BytesRef(packed);
  }
```

实际上就是将多维 byte[] 数据按顺序放置到一个大的 byte[] 中，最后由 IndexWriter 写入索引。


<br/><br/>
<a id="9"></a>
## 2.6.9 XYPointField 子类 XYPointField class ##

&emsp;&emsp;XYPointField 用于索引 2D 空间中由 [X, Y] 表示的位置的域（An indexed XY position field）。是针对二维位置数据进行优化索引的域，通过将 float 型数据编码为整型，再将整型编码成可排序的字节序列，来优化数据搜索性能，用于表示二维几何空间的位置数据。XYPointField 是 PointValues 实现的另一个数值索引应用。

&emsp;&emsp;XYPointField 类型域在一定范围内搜索时非常高效（Finding all documents within a range at search time is efficient）。在一个文档中，这种类型的同一个域拥有多个值是允许的。

&emsp;&emsp;如果需要对每个文档进行操作，例如通过距离排序，则另外添加一个 XYDocValuesField 类型的域。如果要存储该域的值，可以向文档中单独添加一个 StoredField 类型的域。

下面是 XYPointField 的域类型配置和构造器代码：

```
  /**
   * Type for an indexed XYPoint
   * <p>
   * Each point stores two dimensions with 4 bytes per dimension.
   */
  public static final FieldType TYPE = new FieldType();
  static {
    TYPE.setDimensions(2, Integer.BYTES);
    TYPE.freeze();
  }

  /**
   * Creates a new XYPoint with the specified x and y
   * @param name field name
   * @param x x value.
   * @param y y value.
   */
  public XYPointField(String name, float x, float y) {
    super(name, TYPE);
    setLocationValue(x, y);
  }
```

看得出，XYPointField 使用二维整型设置数据维度：TYPE.setDimensions(2, Integer.BYTES); 然后调用 setLocationValue(x, y) 方法对 x, y 两个 float 型数据进行 int 和 byte[] 类型编码。代码如下：

```
  /**
   * Change the values of this field
   * @param x x value.
   * @param y y value.
   */
  public void setLocationValue(float x, float y) {
    final byte[] bytes;
    if (fieldsData == null) {
      bytes = new byte[8];
      fieldsData = new BytesRef(bytes);
    } else {
      bytes = ((BytesRef) fieldsData).bytes;
    }
    int xEncoded = XYEncodingUtils.encode(x);
    int yEncoded = XYEncodingUtils.encode(y);
    NumericUtils.intToSortableBytes(xEncoded, bytes, 0);
    NumericUtils.intToSortableBytes(yEncoded, bytes, Integer.BYTES);
  }
```

编码过程是将两个 float 型数据编码为可排序的 int 型，然后再将可排序的 int 数据编码为可排序的字节数组，并排放置在同一个字节数组 bytes 中，最后由 IndexWriter 写入索引。

<br/><br/>
<a id="10"></a>
## 2.6.10 LatLonPoint 子类 LatLonPoint class ##

&emsp;&emsp;LatLonPoint 表示索引地理位置数据的域（An indexed location field）。

&emsp;&emsp;LatLonPoint 类型域在一定范围内搜索时非常高效（Finding all documents within a range at search time is efficient）。在一个文档中，这种类型的同一个域可以拥有多个值。

&emsp;&emsp;如果需要对每个文档进行操作，例如通过距离排序，则另外添加一个 LatLonDocValuesField 类型的域。如果要存储该域的值，可以向文档中单独添加一个 StoredField 类型的域。

>警告： 索引时会有一些 double 值的精度损失，纬度部分（latitude component） 会有 4.190951585769653E-8 的损失，经度部分（longitude component）会有 8.381903171539307E-8 的损失。

&emsp;&emsp;LatLonPoint 与 XYPointField 类型非常类似，二者都表示一个二维空间上的点。区别在于 XYPointField 使用 2 个 float 型数据表示一个二维几何平面上的位置数据，而 LatLonPoint 使用 2 个 double 型数据表示一个二维地理平面上的位置数据。


下面是 LatLonPoint 的域类型配置和构造器代码：

```
  /**
   * Type for an indexed LatLonPoint
   *
   * <p>Each point stores two dimensions with 4 bytes per dimension.
   */
  public static final FieldType TYPE = new FieldType();

  static {
    TYPE.setDimensions(2, Integer.BYTES);
    TYPE.freeze();
  }

  /**
   * Creates a new LatLonPoint with the specified latitude and longitude
   *
   * @param name field name
   * @param latitude latitude value: must be within standard +/-90 coordinate bounds.
   * @param longitude longitude value: must be within standard +/-180 coordinate bounds.
   * @throws IllegalArgumentException if the field name is null or latitude or longitude are out of
   *     bounds
   */
  public LatLonPoint(String name, double latitude, double longitude) {
    super(name, TYPE);
    setLocationValue(latitude, longitude);
  }

```
LatLonPoint 使用二维整型设置数据维度：TYPE.setDimensions(2, Integer.BYTES)，然后调用 setLocationValue(latitude, longitude) 方法对 latitude, longitude 两个 double 型数据进行 int 和 byte[] 类型编码。代码如下：

```
  /**
   * Change the values of this field
   *
   * @param latitude latitude value: must be within standard +/-90 coordinate bounds.
   * @param longitude longitude value: must be within standard +/-180 coordinate bounds.
   * @throws IllegalArgumentException if latitude or longitude are out of bounds
   */
  public void setLocationValue(double latitude, double longitude) {
    final byte[] bytes;

    if (fieldsData == null) {
      bytes = new byte[8];
      fieldsData = new BytesRef(bytes);
    } else {
      bytes = ((BytesRef) fieldsData).bytes;
    }

    int latitudeEncoded = encodeLatitude(latitude);
    int longitudeEncoded = encodeLongitude(longitude);
    NumericUtils.intToSortableBytes(latitudeEncoded, bytes, 0);
    NumericUtils.intToSortableBytes(longitudeEncoded, bytes, Integer.BYTES);
  }

```
经度 longitude 和 纬度 latitude 有各自的取值范围，经度：-180 <= longitude <= +180，纬度 -90 <= latitude <= +90，单位是度，为 double 类型值。latitude 和 longitude 分别使用各自的编码方法将 double 类型值编码为 int 类型。然后使用 NumericUtils 的工具方法将两个编码后的 int 值编码为可排序的字节数组，并且编码到同一个字节数组 bytes 中。最后由 IndexWriter 写入索引。



<br/><br/>
<a id="11"></a>
## 2.6.11 IntRange 子类 IntRange sugar subclass ##

&emsp;&emsp;**Range 系列子类是 **Point 系列多维数值型索引域的扩展，将表示多维空间点的一个数据扩展为两个，用两个多维数据表示一个多维数据的范围，表示多维数据的最小值和最大值。

&emsp;&emsp;IntRange 表示为一个被索引的整型的多维数据范围域（An indexed Integer Range field）。它支持最多 4 维空间的数据范围，即索引 8 个数值型值，其中 4 个用于表示最小值，另外 4 个表示最大值。使用 1 维数值表示一个整型的数据范围，2 维的数值表示为一个矩形的边界，3 维的数值表示为一个立方体的边界，4 维的数值表示为四维超立方体（tesseract）边界。

&emsp;&emsp;支持在一个文档中，此种类型的同一个域拥有多个值。开放边界范围可以使用 Integer.MIN_VALUE 和 Integer.MAX_VALUE 定义。

查看 IntRange 构造器代码：
```
  /**
   * Create a new IntRange type, from min/max parallel arrays
   *
   * @param name field name. must not be null.
   * @param min range min values; each entry is the min value for the dimension
   * @param max range max values; each entry is the max value for the dimension
   */
  public IntRange(String name, final int[] min, final int[] max) {
    super(name, getType(min.length));
    setRangeValues(min, max);
  }
  ```
最小值 min 和 最大值 max 都是多维整型数值 int[]，且维数相同，每一维上的数据都是 int 整型值。域类型选项配置通过 getType(min.length) 方法获取，最小值和最大值的维数是相同的，使用哪一个维数都可以，这里使用最小值的维数作为参数传递给 getType() 方法。

下面是 getType 方法源码：
```
  /** stores integer values so number of bytes is 4 */
  public static final int BYTES = Integer.BYTES;

  /** set the field type */
  private static FieldType getType(int dimensions) {
    if (dimensions > 4) {
      throw new IllegalArgumentException("IntRange does not support greater than 4 dimensions");
    }

    FieldType ft = new FieldType();
    // dimensions is set as 2*dimension size (min/max per dimension)
    ft.setDimensions(dimensions*2, BYTES);
    ft.freeze();
    return ft;
  }
```
IntRange 类中定义了静态的 int 型 BYTES 常量，它的值是 Integer 整型数据占用的字节数，值为 4。getType() 方法首先检查数据的维数是否大于 4，如果大于 4，表明这是一个非法的参数，抛出 IllegalArgumentException 异常。然后设置域类型维度选项为 ft.setDimensions(dimensions*2, BYTES)。域选项设置维度为传入维数 dimensions 的 2 倍，因为 IntRange 要存入最小值和最大值 2 个多维数值。每个维度数据占用字节数为常量 BYTES，值为 4。

构造器调用 setRangeValues(min, max) 方法来初始化 IntRange 的数据值。代码如下：
```
  /**
   * Changes the values of the field.
   * @param min array of min values. (accepts {@code Integer.NEGATIVE_INFINITY})
   * @param max array of max values. (accepts {@code Integer.POSITIVE_INFINITY})
   * @throws IllegalArgumentException if {@code min} or {@code max} is invalid
   */
  public void setRangeValues(int[] min, int[] max) {
    checkArgs(min, max);
    if (min.length*2 != type.pointDimensionCount() || max.length*2 != type.pointDimensionCount()) {
      throw new IllegalArgumentException("field (name=" + name + ") uses " + type.pointDimensionCount()/2
          + " dimensions; cannot change to (incoming) " + min.length + " dimensions");
    }

    final byte[] bytes;
    if (fieldsData == null) {
      bytes = new byte[BYTES*2*min.length];
      fieldsData = new BytesRef(bytes);
    } else {
      bytes = ((BytesRef)fieldsData).bytes;
    }
    verifyAndEncode(min, max, bytes);
  }
```
真正的处理逻辑是 verifyAndEncode(min, max, bytes) 的调用，代码如下：
```
  /**
   * encode the ranges into a sortable byte array ({@code Double.NaN} not allowed)
   * <p>
   * example for 4 dimensions (8 bytes per dimension value):
   * minD1 ... minD4 | maxD1 ... maxD4
   */
  static void verifyAndEncode(int[] min, int[] max, byte[] bytes) {
    for (int d=0,i=0,j=min.length*BYTES; d<min.length; ++d, i+=BYTES, j+=BYTES) {
      if (Double.isNaN(min[d])) {
        throw new IllegalArgumentException("invalid min value (" + Double.NaN + ")" + " in IntRange");
      }
      if (Double.isNaN(max[d])) {
        throw new IllegalArgumentException("invalid max value (" + Double.NaN + ")" + " in IntRange");
      }
      if (min[d] > max[d]) {
        throw new IllegalArgumentException("min value (" + min[d] + ") is greater than max value (" + max[d] + ")");
      }
      encode(min[d], bytes, i);
      encode(max[d], bytes, j);
    }
  }
```

关键代码是最后两行：将多维整型数值的最小值和最大值进行二进制编码后，并排放置到 bytes 字节数组中。这就是原始的两个多维整型数据在 IntRange 中存在形式。



<br/><br/>
<a id="12"></a>
## 2.6.12 LongRange 子类 LongRange sugar subclass ##

&emsp;&emsp;与 IntRange 域类似，区别在于 LongRange 多维数据的每一维使用 long 型存储数据，其它特性参考 IntRange 域。

LongRange 构造器：
- **LongRange(String name, long[] min, long[] max)** 使用多维数据最小值和最大值创建 LongRange 对象，表示一个多维数值的范围。long[] min 中每一维的数据都表示此范围在该维上的最小值，long[] max 中每一维的数据都表示此范围在该维上的最大值。min 和 max 必须具有相同的维数。



<br/><br/>
<a id="13"></a>
## 2.6.13 FloatRange 子类 FloatRange sugar subclass ##

&emsp;&emsp;与 IntRange 域类似，FloatRange 多维数据的每一维使用 float 类型存储数据，其它特性参考 IntRange 域。

FloatRange 构造器：
- **FloatRange(String name, float[] min, float[] max)** 使用多维数据最小值和最大值创建 FloatRange 对象，表示一个多维数值的范围。float[] min 中每一维的数据都表示此范围在该维上的最小值，float[] max 中每一维的数据都表示此范围在该维上的最大值。min 和 max 必须具有相同的维数。


<br/><br/>
<a id="14"></a>
## 2.6.14 DoubleRange 子类 DoubleRange sugar subclass ##

&emsp;&emsp;与 IntRange 域类似，DoubleRange 多维数据的每一维使用 double 类型存储数据，其它特性参考 IntRange 域。

DoubleRange 构造器：
- **DoubleRange(String name, double[] min, double[] max)** 使用多维数据最小值和最大值创建 DoubleRange 对象，表示一个多维的数值范围。double[] min 中每一维的数据都表示此范围在该维上的最小值，double[] max 中每一维的数据都表示此范围在该维上的最大值。min 和 max 必须具有相同的维数。


&emsp;&emsp;本节结束了 PointValues 实现的数值类型索引域的探讨。

&emsp;&emsp;以上讨论的 Field 子类，包括文本型数据域和 **Point 类型多维数值域，以及 **Range 表示多维数值范围的域，针对的是不同数据类型建立索引。下面几个小节将介绍与 DocValues 正向索引相关的域，这些域类型针对的是数据在排序和和聚合功能上的特殊处理，以及其它需要正向索引结构定义的域。


<br/><br/>
<a id="15"></a>
## 2.6.15 SortedDocValuesField 子类 SortedDocValuesField sugar subclass ##

&emsp;&emsp;之前在讨论 StringField 类的时候提到过，如果要对某个 StringField 域进行排序，例如要对 'country' 域按国家名排序，或者对 'id' 域按序号大小排序，可以另外再向该文档添加一个 SortedDocValuesField 类型的域。

>JavaDoc: If you also need to sort on this field, separately add a SortedDocValuesField to your document.

&emsp;&emsp;从 SortedDocValuesField 类的名称可以大致了解，这是一个 DocValues 正向索引的域，该域在索引时进行了预先的排序，这样在搜索时就可以快速获得匹配文档的排列顺序，而不是通过计算文档和搜索语句间的相关性评分来进行排序，比如通过 'country' 域按国家名排序。

&emsp;&emsp;SortedDocValuesField 域存储每个文档的 BytesRef 类型值，对这个域进行索引就是为了排序。

>JavaDoc: Field that stores a per-document BytesRef value, indexed for sorting. 

例如：

```
document.add(new SortedDocValuesField(name, new BytesRef("hello")));
```

&emsp;&emsp;Lucene 对 SortedDocValuesField 域值的长度有限制，最大值是 32766 个字节。这是可以理解的，过长的文本串对排序已经没什么意义了，只会增大索引文件的空间。

SortedDocValuesField 构造器：
- SortedDocValuesField(String name, BytesRef bytes) 使用 BytesRef 表示的值创建一个排好序的 DocValues 域，BytesRef 表示的值实际上是一段 byte[] 数组，可能是一段 UTF8 编码的字符串，也有可能是一个经过编码的数值，比如，int, long, float, dobule，它以可排序的字节数组形式持有数据。

&emsp;&emsp;看看 SortedDocValuesField 内部域类型的配置:

```
  /**
   * Type for sorted bytes DocValues
   */
  public static final FieldType TYPE = new FieldType();
  static {
    TYPE.setDocValuesType(DocValuesType.SORTED);
    TYPE.freeze();
  }
```

&emsp;&emsp;代码设置域类型选项 DocValuesType 为 DocValuesType.SORTED 值，表明该域类型是预先排好序的 DocValues 类型。这种类型域值只存储它自己不同部分的字节值，而另外相同部分的数据存储在共享的字节数组中，每个文档会存储另外一个偏移量指针，用于指向共享字节数组。也就是说，SORTED 选项的域，将域的值拆分成两个部分，不同的部分自己存储，相同的部分与其它文档共享，只存储一份。这种结构不仅降低了索引文件空间的大小，还优化了数据比较，只比较其中一小部分不同的数据就可以了，而相同部分的数据不必参加比较，这正是数据排序功能所需要的。

&emsp;&emsp;域类型配置中其它选项为默认值，而 FieldType 的 stored 选项默认为 false，即 SortedDocValuesField 域不支持数据存储。如果要存储该域的值，可以向文档中单独添加一个 StoredField 类型的域。

SortedDocValuesField 构造器代码：

```
  /**
   * Create a new sorted DocValues field.
   * @param name field name
   * @param bytes binary content
   * @throws IllegalArgumentException if the field name is null
   */
  public SortedDocValuesField(String name, BytesRef bytes) {
    super(name, TYPE);
    fieldsData = bytes;
  }
```

SortedDocValuesField 构造器代码没有特殊逻辑，使用上述配置好的内置域类型调用父类 Field 的无域值构造器，将 BytesRef 类型值数据赋值给类中域值字段 fieldsData = bytes。

&emsp;&emsp; SortedDocValuesField 主要的作用是提供字符串值的排序功能（如根据检索条件筛选出结果集后根据某个字符类型的字段进行排序）。



<br/><br/>
<a id="16"></a>
## 2.6.16 BinaryDocValuesField 子类 BinaryDocValuesField sugar subclass ##

&emsp;&emsp;BinaryDocValuesField 域存储每个文档的 BytesRef 类型值。BinaryDocValuesField 与SortedDocValuesField 相似，它们都是 DocValues 的正向索引，使用列式存储。当域的值重复项较少，或者共同前缀较少时使用 BinaryDocValuesField 存储较好，也就是说，BinaryDocValuesField 域的值被直接存储，不与其它的 BinaryDocValuesField 域的值共享同一个值或者部分前缀，比如 'title' 域。而 SortedDocValuesField 为了在索引时将数据排好序，对域值重复项较多，或者共同前缀较多的值，表现良好。


>JavaDoc: The values are stored directly with no sharing, which is a good fit when the fields don't share (many) values, such as a title field. If values may be shared and sorted it's better to use SortedDocValuesField. 

用法示例：

```
document.add(new BinaryDocValuesField(name, new BytesRef("hello")));
```

查看内置域类型配置代码：

```
  /**
   * Type for straight bytes DocValues.
   */
  public static final FieldType TYPE = new FieldType();
  static {
    TYPE.setDocValuesType(DocValuesType.BINARY);
    TYPE.freeze();
  }
```

内置域类型设置 DocValuesType 为 DocValuesType.BINARY 值，域值每个文档存储一个完整的字节数组，就是说不与其它文档共享或部分共享数据。其它选项为默认值，而 FieldType 的 stored 选项默认为 false，即 BinaryDocValuesField 域是不支持存储的。如果要存储该域的值，可以向文档中单独添加一个 StoredField 类型的域。

查看 BinaryDocValuesField 构造器代码:

```
  /**
   * Create a new binary DocValues field.
   * @param name field name
   * @param value binary content
   * @throws IllegalArgumentException if the field name is null
   */
  public BinaryDocValuesField(String name, BytesRef value) {
    super(name, TYPE);
    fieldsData = value;
  }
```

BinaryDocValuesField 构造器代码和 SortedDocValuesField 构造器同样简单，不同的就是域类型选项配置的不同，结果就是二者存储数据的方式不同，表现为不同的特性。



<br/><br/>
<a id="17"></a>
## 2.6.17 SortedSetDocValuesField 类 SortedSetDocValuesField sugar subclass ##

&emsp;&emsp;SortedSetDocValuesField 类在每个文档中存储一批数据，具有相同域名、不同的域值。索引这类数据的目的是为了应对数量特别大的索引时，进行分组、联合，facet 查询，进而提升了查询效率（Field that stores a set of per-document BytesRef values, indexed for faceting,grouping,joining）。在讨论 facet 查询时，还会探讨 SortedSetDocValuesField 类型域的特点。

使用示例：
```
   document.add(new SortedSetDocValuesField(name, new BytesRef("hello")));
   document.add(new SortedSetDocValuesField(name, new BytesRef("world")));
```


构造器代码：

```
  /**
   * Type for sorted bytes DocValues
   */
  public static final FieldType TYPE = new FieldType();
  static {
    TYPE.setDocValuesType(DocValuesType.SORTED_SET);
    TYPE.freeze();
  }

  /**
   * Create a new sorted DocValues field.
   * @param name field name
   * @param bytes binary content
   * @throws IllegalArgumentException if the field name is null
   */
  public SortedSetDocValuesField(String name, BytesRef bytes) {
    super(name, TYPE);
    fieldsData = bytes;
  }
```

&emsp;&emsp;域类型设置为 TYPE.setDocValuesType(DocValuesType.SORTED_SET); 表明该域类型是预先排好序的 DocValues 类型。与 SortedSetDocValuesField 类型类似，只是在索引文件内部，数据是预先排好序的 Set<byte[]> 类型。数据存储方式与 SORTED 选项一样，域值只存储它自己不同部分的字节值，而另外相同部分的数据存储在共享的字节数组中，每个文档会存储另外一个偏移量指针，用于指向共享字节数组。也就是说，SORTED 选项的域，将域的值拆分成两个部分，不同的部分自己存储，相同的部分与其它文档共享，只存储一份。这种结构不仅降低了索引文件空间的大小，还优化了数据比较，只比较其中一小部分不同的数据就可以了，而相同部分的数据不必参加比较，这正是数据排序功能所需要的。存储的域值可以通过文档 id （DocID）、序号（ordinal）访问。要求域值数据必须小于或等于 32766 个字节。

&emsp;&emsp;域类型配置中其它选项为默认值，而 FieldType 的 stored 选项默认为 false，即 SortedDocValuesField 域不支持数据存储。如果要存储该域的值，可以向文档中单独添加一个 StoredField 类型的域。

<br/><br/>
<a id="18"></a>
## 2.6.18 NumericDocValuesField 类 NumericDocValuesField sugar subclass ##

&emsp;&emsp;NumericDocValuesField 是每个文档存储的 long 型值域，用于文档评分、排序、或者值检索（Field that stores a per-document long value for scoring, sorting or value retrieval）。

用法示例：
```
document.add(new NumericDocValuesField(name, 22L));
```

如果要存储该域的值，可以向文档中单独添加一个 StoredField 类型的域。

先看看域类型配置代码：

```
  /**
   * Type for numeric DocValues.
   */
  public static final FieldType TYPE = new FieldType();
  static {
    TYPE.setDocValuesType(DocValuesType.NUMERIC);
    TYPE.freeze();
  }
```
内置的域类型配置 DocValuesType 为 NUMERIC: TYPE.setDocValuesType(DocValuesType.NUMERIC); 即正向索引中每个文档单独存储的数值型域。

两个构造器代码：

```
  /** 
   * Creates a new DocValues field with the specified 64-bit long value 
   * @param name field name
   * @param value 64-bit long value
   * @throws IllegalArgumentException if the field name is null
   */
  public NumericDocValuesField(String name, long value) {
    this(name, Long.valueOf(value));
  }

  /**
   * Creates a new DocValues field with the specified 64-bit long value
   * @param name field name
   * @param value 64-bit long value or <code>null</code> if the existing fields value should be removed on update
   * @throws IllegalArgumentException if the field name is null
   */
  public NumericDocValuesField(String name, Long value) {
    super(name, TYPE);
    fieldsData = value;
  }
```

前一个构造器调用了后面的构造器，实际上是一个逻辑：将对象型 Long 数值保存到 fieldsData 实例字段，即用指定的 64-bit long 型值创建一个 DocValues 类型域。


<br/><br/>
<a id="19"></a>
## 2.6.19 DoubleDocValuesField 类 DoubleDocValuesField sugar subclass ##

&emsp;&emsp;DoubleDocValuesField 类是 NumericDocValuesField 类的语法糖子类，它是将 double 类型的数据参数通过 Java 原生方法 Double.doubleToRawLongBits(double) 转换为 long 型，之后调用父类 NumericDocValues 构造器创建对象，与 NumericDocValues 具有相同的特性。

构造器代码：
```
  /** 
   * Creates a new DocValues field with the specified 64-bit double value 
   * @param name field name
   * @param value 64-bit double value
   * @throws IllegalArgumentException if the field name is null
   */
  public DoubleDocValuesField(String name, double value) {
    super(name, Double.doubleToRawLongBits(value));
  }

```

<br/><br/>
<a id="20"></a>
## 2.6.20 FloatDocValuesField 类 FloatDocValuesField sugar subclass ##

&emsp;&emsp;与 DoubleDocValuesField 类似，也是 NumericDocValuesField 类的语法糖子类，它是将 float 类型的数据参数通过 Java 原生方法 Float.floatToRawIntBits(float) 转换为 int 型，之后调用父类 NumericDocValues 构造器创建对象,与 NumericDocValues 具有相同的特性。

构造器代码：

```
  /** 
   * Creates a new DocValues field with the specified 32-bit float value 
   * @param name field name
   * @param value 32-bit float value
   * @throws IllegalArgumentException if the field name is null
   */
  public FloatDocValuesField(String name, float value) {
    super(name, Float.floatToRawIntBits(value));
  }
```

<br/><br/>
<a id="21"></a>
## 2.6.21 SortedNumericDocValuesField 类 SortedNumericDocValuesField sugar subclass ##

&emsp;&emsp;每个文档存储一个的 long 型数值域，用于文档评分、排序、或者值检索。

用法示例：

```
   document.add(new SortedNumericDocValuesField(name, 5L));
   document.add(new SortedNumericDocValuesField(name, 14L));
```

看看内置域类型选项配置代码：

  /**
   * Type for sorted numeric DocValues.
   */
  public static final FieldType TYPE = new FieldType();
  static {
    TYPE.setDocValuesType(DocValuesType.SORTED_NUMERIC);
    TYPE.freeze();
  }

内置的域类型配置 DocValuesType 为 SORTED_NUMERIC: TYPE.setDocValuesType(DocValuesType.SORTED_NUMERIC); 即正向索引中每个文档单独存储的、排好序的数值型域。SORTED_NUMERIC 型的 DocValues 类型的域，数据存储在 Number[] 中，存储数据时，根据 Java 语言原生方法 Long.compare(long, long) 排序顺序存储。

查看构造器代码：

```
  /** 
   * Creates a new DocValues field with the specified 64-bit long value 
   * @param name field name
   * @param value 64-bit long value
   * @throws IllegalArgumentException if the field name is null
   */
  public SortedNumericDocValuesField(String name, long value) {
    super(name, TYPE);
    fieldsData = Long.valueOf(value);
  }

```
将对象型 Long 数值保存到 fieldsData 实例字段，即用指定的 64-bit long 型值创建一个 DocValues 类型域。

>提示：如果要将编码的 double 或 float 型数据以正确的排序顺序存储，需要使用 NumericUtils 工具类对其编码。
>```document.add(new SortedNumericDocValuesField(name, NumericUtils.floatToSortableInt(-5.3f)));``` 
>```document.add(new SortedNumericDocValuesField(name, NumericUtils.doubleToSortableLong(7.6L)));```

如果要存储该域的值，可以向文档中单独添加一个 StoredField 类型的域。


<br/><br/>
<a id="22"></a>
## 2.6.22 DoubleRangeDocValuesField 类 DoubleRangeDocValuesField sugar subclass ##

&emsp;&emsp;DoubleRange 的 DocValues 域，是 BinaryDocValuesField 类的子类扩展。

构造器代码：
```
  public DoubleRangeDocValuesField(String field, final double[] min, final double[] max) {
    super(field, DoubleRange.encode(min, max), min.length, DoubleRange.BYTES);
    checkArgs(min, max);
    this.field = field;
    this.min = min;
    this.max = max;
  }
```

将多维 double 型最小值数据 min 和最大值数据 max，先编码为可排序的 long 型，然后按序编码为可排序字节数组，再按序存放在一个字节数组中，最后调用父类 BinaryDocValuesField 构造器创建 DoubleRange 的 DocValues 域。

<br/><br/>
<a id="23"></a>
## 2.6.23 FloatRangeDocValuesField 类 FloatRangeDocValuesField sugar subclass ##

&emsp;&emsp;FloatRange 的 DocValues 域，是 BinaryDocValuesField 类的子类扩展。

构造器代码：
```
  public FloatRangeDocValuesField(String field, final float[] min, final float[] max) {
    super(field, FloatRange.encode(min, max), min.length, FloatRange.BYTES);
    checkArgs(min, max);
    this.field = field;
    this.min = min;
    this.max = max;
  }
```
将多维 float 型最小值数据 min 和最大值数据 max，先编码为可排序的 int 型，然后按序编码为可排序字节数组，再按序存放在一个字节数组中，最后调用父类 BinaryDocValuesField 构造器创建 FloatRange 的 DocValues 域。

<br/><br/>
<a id="24"></a>
## 2.6.24 IntRangeDocValuesField 类 IntRangeDocValuesField sugar subclass ##

&emsp;&emsp;IntRange 的 DocValues 域，是 BinaryDocValuesField 类的子类扩展。

构造器代码：

```
  public IntRangeDocValuesField(String field, final int[] min, final int[] max) {
    super(field, IntRange.encode(min, max), min.length, IntRange.BYTES);
    checkArgs(min, max);
    this.field = field;
    this.min = min;
    this.max = max;
  }
```

将多维 int 型最小值数据 min 和最大值数据 max，编码为可排序字节数组，再按序存放在一个字节数组中，最后调用父类 BinaryDocValuesField 构造器创建 IntRange 的 DocValues 域。

<br/><br/>
<a id="25"></a>
## 2.6.25 LongRangeDocValuesField 类 LongRangeDocValuesField sugar subclass ##

&emsp;&emsp;LongRange 的 DocValues 域，是 BinaryDocValuesField 类的子类扩展。

构造器代码：
```
  public LongRangeDocValuesField(String field, final long[] min, final long[] max) {
    super(field, LongRange.encode(min, max), min.length, LongRange.BYTES);
    checkArgs(min, max);
    this.field = field;
    this.min = min;
    this.max = max;
  }
```

将多维 long 型最小值数据 min 和最大值数据 max，编码为可排序字节数组，再按序存放在一个字节数组中，最后调用父类 BinaryDocValuesField 构造器创建 LongRange 的 DocValues 域。


<br/><br/>
<a id="26"></a>
## 2.6.26 XYDocValuesField 类 XYDocValuesField sugar subclass ##

&emsp;&emsp;二维几何平面每文档存储的点位置 DocValues 域（An per-document location field）。

&emsp;&emsp;XYDocValuesField 按距离排序非常高效。一个文档中，允许同一个 XYDocValuesField 域的多个值。

内置域类型选项配置：

```
  /**
   * Type for a XYDocValuesField
   * <p>
   * Each value stores a 64-bit long where the upper 32 bits are the encoded x value,
   * and the lower 32 bits are the encoded y value.
   * @see org.apache.lucene.geo.XYEncodingUtils#decode(int)
   */
  public static final FieldType TYPE = new FieldType();
  static {
    TYPE.setDocValuesType(DocValuesType.SORTED_NUMERIC);
    TYPE.freeze();
  }

```
内置域类型设置 DocValuesType 选项为 SORTED_NUMERIC，表明 XYDocValuesField 域是预先排好序的数值型 DocValues 域。

查看构造器代码：
```
  /**
   * Creates a new XYDocValuesField with the specified x and y
   * @param name field name
   * @param x x value.
   * @param y y values.
   * @throws IllegalArgumentException if the field name is null or x or y are infinite or NaN.
   */
  public XYDocValuesField(String name, float x, float y) {
    super(name, TYPE);
    setLocationValue(x, y);
  }
```
关键代码是 setLocationValue(x, y) 方法调用，查看该方法代码：

```
  /**
   * Change the values of this field
   * @param x x value.
   * @param y y value.
   * @throws IllegalArgumentException  if x or y are infinite or NaN.
   */
  public void setLocationValue(float x, float y) {
    int xEncoded = XYEncodingUtils.encode(x);
    int yEncoded = XYEncodingUtils.encode(y);
    fieldsData = Long.valueOf((((long) xEncoded) << 32) | (yEncoded & 0xFFFFFFFFL));
  }
```

用指定 float 型二维平面某个点的坐标值 x 和 y 设置数据值，将两个 float 型数据 x 和 y 分别编码为可排序的 int 型，然后将其拼接为一个 64 位 Long 型数值存储在 fieldsData 字段中，其中高32位存储 x 值，低32位存储 y 值。

&emsp;&emsp;如果要对该域持有的值进行查询，单独添加一个 XYPointField 域。如果要存储该域的值，向文档中单独添加一个 StoredField 类型的域。


<br/><br/>
<a id="27"></a>
## 2.6.27 LatLonDocValuesField 类 LatLonDocValuesField sugar subclass ##

&emsp;&emsp;二维地理平面每文档存储的点位置 DocValues 域（An per-document location field）。

&emsp;&emsp;LatLonDocValuesField 按距离排序非常高效。一个文档中，允许同一个 LatLonDocValuesField 域的多个值。

查了内置域类型选项配置：
```
  /**
   * Type for a LatLonDocValuesField
   *
   * <p>Each value stores a 64-bit long where the upper 32 bits are the encoded latitude, and the
   * lower 32 bits are the encoded longitude.
   *
   * @see org.apache.lucene.geo.GeoEncodingUtils#decodeLatitude(int)
   * @see org.apache.lucene.geo.GeoEncodingUtils#decodeLongitude(int)
   */
  public static final FieldType TYPE = new FieldType();

  static {
    TYPE.setDocValuesType(DocValuesType.SORTED_NUMERIC);
    TYPE.freeze();
  }

```
内置域类型设置 DocValuesType 选项为 SORTED_NUMERIC，表明 LatLonDocValuesField 域是预先排好序的数值型 DocValues 域。

查看构造器代码：
```
  /**
   * Creates a new LatLonDocValuesField with the specified latitude and longitude
   *
   * @param name field name
   * @param latitude latitude value: must be within standard +/-90 coordinate bounds.
   * @param longitude longitude value: must be within standard +/-180 coordinate bounds.
   * @throws IllegalArgumentException if the field name is null or latitude or longitude are out of
   *     bounds
   */
  public LatLonDocValuesField(String name, double latitude, double longitude) {
    super(name, TYPE);
    setLocationValue(latitude, longitude);
  }
```

用指定 double 型二维地理位置点的坐标值 latitude 和 longitude 设置 LatLonDocValuesField 实例的数据值，将两个 double 型数据分别编码为可排序的32位 int 型，然后将其拼接为一个 64 位 Long 型数值存储在 fieldsData 字段中，其中高32位存储的是 latitude 值，低32位存储的是 longitude 值。

&emsp;&emsp;如果要对该域持有的值进行查询，单独添加一个 LatLonPoint 域。如果要存储该域的值，向文档中单独添加一个 StoredField 类型的域。

>警告：索引地理数据相对原始的 double 型数据有一定的精度损失。纬度 latitude 损失 4.190951585769653E-8，经度  longitude 损失 8.381903171539307E-8。


<br/><br/>
<a id="28"></a>
## 2.6.28 FeatureField 类 FeatureField sugar subclass ##

&emsp;&emsp;**FeatureField** 从 Lucene 7.4 开始引入，是 Lucene 一个非常高级的特性。表示用于将静态评分因子存储到文档中的域（Field that can be used to store static scoring factors into documents）。关于这个域的特性，主要的灵感来自于 Nick Craswell, Stephen Robertson, Hugo Zaragoza and Michael Taylor 的工作。查询的相关性权重计算独立性证明（Relevance weighting for query independent evidence）。

&emsp;&emsp;特性（Feature）值在内部被编码为词项的频率（Feature values are internally encoded as term frequencies）。将特性查询作为布尔查询的 BooleanClause.Occur.SHOULD 子句，可以通过线性合并的方式将查询依赖的评分（例如 BM25）与查询不依赖的评分合并。将特性值作为词频存储的事实，在不请求命中总数时，允许搜索逻辑高效地跳过那些不具竞争力的文档。这使它相较于将这样的因子数据存储到别处，例如一个 DocValues 域，是一个更好的选项。

&emsp;&emsp;FeatureField 域可以只存储与最终评分正向相关的因子，例如 pagerank。在因子与评分反向相关的情况下，存储反向相关的评分因子，例如 url 长度，存储评分因子为 1/urlLength。

&emsp;&emsp;由于存储效率的原因，FeatureField 域在内部允许将数据存储在16位空间，但只考虑最多 9 个有效位。实际上，这种限制意味着值的存储，有 2<sup>-8</sup> = 0.00390625 的相对精度。

给定一个评分因子（scoring factor） S > 0，以及它的权重（weight） w > 0，那么，有四种方案通过 S 计算得到评分（score）：
- w * log(a + S)，其中 a >= 1。这个函数通常情况下是合乎情理的，因为评分因子的分配经常跟着一个幂律。典型的应用是 pagerank 实例。然而，论文中建议 satu 和 sigm 函数会给出更好的结果。
- satu(S) = w * S / (S + k), 其中 k > 0。satu 代表饱和度，即单词 saturation。这个函数类似于 BM25Similarity 使用的饱和度算法，目的是为了将词频混入到最终的评分，并生成 0 到 1 间的值。当 S 和 k 相等时，值为 0.5 。
- sigm(S) = w * S<sup>a</sup> / (S<sup>a</sup> + k<sup>a</sup>), 其中 k > 0, a > 0。sigm 表示 S 形，即单词 sigmoid。这个函数提供了比上面两个函数更好的结果，但由于它有两个参数，因此也更加难以调节。
- w * S 这个是高级算法。这个函数没有对索引的特性值进行任何变换，只是用索引的特性值本身，与文档权重相乘，确定最终评分。这样，就要求用某种方法将特性值编码到索引中，用以计算最终的评分。

&emsp;&emsp;上面公式中的常量通常需要反复实践来计算出最优的值。如果不知道从哪儿开始，FeatureField.newSaturationQuery(String fieldName, String featureName) 方法使用 1.0f 作为权重值（weight），并且基于索引的统计信息猜想一个有意义的值作为饱和度的中心点参数，不会执行得太差。

假设文档中有一个 FeatureField 的域，fieldName 为 'features'，存储的是 'pagerank' 特性的值。

用法示例：

```
 Query query = new BooleanQuery.Builder()
     .add(new TermQuery(new Term("body", "apache")), Occur.SHOULD)
     .add(new TermQuery(new Term("body", "lucene")), Occur.SHOULD)
     .build();
 Query boost = FeatureField.newSaturationQuery("features", "pagerank");
 Query boostedQuery = new BooleanQuery.Builder()
     .add(query, Occur.MUST)
     .add(boost, Occur.SHOULD)
     .build();
 TopDocs topDocs = searcher.search(boostedQuery, 10);
```

&emsp;&emsp;说起来很复杂，实际用起来也没那么麻烦。Lucene 将理论上的复杂性屏蔽在简单的用户级 API 之下，使我们使用这些公开的简单编程接口，将非常高级的 FeatureField 特性应用到自己的程序中来。上面代码中：
```
    Query boost = FeatureField.newSaturationQuery("features", "pagerank");
```
基于 'features' 域 'pagerank' 特性创建了一个饱和度查询，把这个查询以 Occur.SHOULD 子句形式加入到布尔查询中，这样就将特性查询和主查询关联起来，使用特性查询的加权值来影响主查询的最终查询结果。

深入到代码中，探索一下内置域类型的选项：
```
  private static final FieldType FIELD_TYPE = new FieldType();
  static {
    FIELD_TYPE.setTokenized(false);
    FIELD_TYPE.setOmitNorms(true);
    FIELD_TYPE.setIndexOptions(IndexOptions.DOCS_AND_FREQS);
  }

```
选项中 FIELD_TYPE.setTokenized(false) 表明域不进行分词，即将特性名作为一个单一的词元（token），同时也不存在词频数据。FIELD_TYPE.setOmitNorms(true) 表明忽略 Norms 信息的存储。**FIELD_TYPE.setIndexOptions(IndexOptions.DOCS_AND_FREQS)** 表明索引特性名词元，并存储词频，这里是关键，因为特性值就是作为词频存储的。但这里存储的词频不是特性名真正的词频，而是将构造器传进来的特性值（feature value）作为词频存储起来。这是 FeatureField 域最明显的特征，也是它最巧妙的地方，有别于一般的 Field 的设计。

查看 FeatureField 构造器代码：
```
  private float featureValue;

  /**
   * Create a feature.
   * @param fieldName The name of the field to store the information into. All features may be stored in the same field.
   * @param featureName The name of the feature, eg. 'pagerank`. It will be indexed as a term.
   * @param featureValue The value of the feature, must be a positive, finite, normal float.
   */
  public FeatureField(String fieldName, String featureName, float featureValue) {
    super(fieldName, featureName, FIELD_TYPE);
    setFeatureValue(featureValue);
  }
```

构造器代码很简单：super(fieldName, featureName, FIELD_TYPE) 调用父类 Field 的构造器，传给父类的域值，就是 String 类型的特性的名称，例如上面示例的 'pagerank` 字符串。float 型特性值的存储通过 setFeatureValue(featureValue) 调用。

查看 setFeatureValue 方法代码：

```
  /**
   * Update the feature value of this field.
   */
  public void setFeatureValue(float featureValue) {
    if (Float.isFinite(featureValue) == false) {
      throw new IllegalArgumentException("featureValue must be finite, got: " + featureValue +
          " for feature " + fieldsData + " on field " + name);
    }
    if (featureValue < Float.MIN_NORMAL) {
      throw new IllegalArgumentException("featureValue must be a positive normal float, got: " +
          featureValue + " for feature " + fieldsData + " on field " + name +
          " which is less than the minimum positive normal float: " + Float.MIN_NORMAL);
    }
    this.featureValue = featureValue;
  }

```
没有经过任何变换，直接将特性值 featureValue 保存到 FeatureField 类内部的私有变量 private float featureValue 中。

关于 FeatureField 域的讨论就暂时到这里，当探讨搜索功能时，还会讨论它在查询方面的特性。

&emsp;&emsp;这是本章最长的一节，因为 Field 子类非常多，以适应不同的索引和查询需求。虽然类型很多，常用的也就是前面介绍的几种。








